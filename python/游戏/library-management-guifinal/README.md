# Library Management

Python 小课堂 2023 第三堂课的项目，用于训练面向对象程序设计和 Pandas 库的应用。

## 目标

根据框架代码补充完成图书管理系统。

## 代码结构

- main.py : 运行入口
- book.py : 书籍类
- account.py : 用户类
- database.py : 数据库类，需要补全的代码主要在这个文件里
- exceptions.py : 包含部分异常，有兴趣的同学可以了解异常捕获相关内容

## 运行与测试

每写一段代码都进行充分的测试是一个好习惯。

部分文件最后会有一些测试用例，以 `if __name__=='__main__':`（可以查找资料了解这条语句的含义）开头。

你也可以编写自己的测试用例。在一个复杂的系统里，bug 几乎不可避免，对于开发者而言，所能做的事只有：测试，多做测试。

## 杂谈：为什么我们需要面向对象

> 作者：cht

因为面向对象是好文明。

面向对象不仅是一种程序设计范式，更是一种世界观，将现实世界抽象为事物和它们之间的联系。它天然包含一种整体的视角，这是符合直觉的。

比方说有这样一个事件，我们把它描述成 `Student.write(Homework)`，大家一眼就能看明白它的意思。从另一个角度说，我们设计一个作业管理系统，并不需要了解每个人写作业的具体细节（每个学生实例的 `write` 方法甚至可能有不同的行为），只需要调用他们的接口，然后相信他们真能写完。

如果继续探究下去，我们还可以看到 Python 的 duck typing 思想：如果一个东西看起来像鸭子，叫起来像鸭子，那么它就是鸭子。同理，如果一个东西能写作业，那么它在我们的管理系统里就可以当作学生。比如我们定义这样一个函数 `Student.ask_for_help(Student)`，然后你就可以这样使用：`me.ask_for_help(ChatGPT)`，只需要 ChatGPT 也定义了 `write` 方法。

总而言之，面向对象使我们不必去理解每个部分如何发挥作用，只需要了解事物作为整体的特性，以及它所提供的接口。

在一个复杂的系统里，没有人能了解程序运行的一切细节。一般采取的方法是：用户管理最上层的对象，上层管理中层，中层管理底层。每个对象只保证自己内部不出错，只对调用自己的对象负责。实际上，这与现实中的管理理论是相通的。这种设计方式能够最小化每个对象的负担（或者说，代码量），从而使整个系统灵活可拓展。

> 作者：yhj137

首先我们先来了解一下，什么是面向对象式编程。

根据维基百科的定义（看不懂也没关系）：

面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、特性、代码与方法。对象则指的是类（class）的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。

上面的定义很复杂，但实际上就是在说：面向对象式程序由一个个对象组成，而对象又由方法与数据组成。面向对象的思想其实相当直观，因为它其实也是一种世界观，即将世界上抽象为一个个对象和它们之间的联系。映射到我们的面向对象式编程里，我们实际上是把程序抽象为了一个个类的实例（即对象），类的实例之间可以通过方法进行交互，以达成对数据的处理。考虑下面一个例子（摘自知乎）：

问题： 洗衣机里面放有脏衣服，怎么洗干净？

面向过程的解决方法：

1. 执行加洗衣粉方法；

2. 执行加水方法；

3. 执行洗衣服方法；

4. 执行清洗方法；

5. 执行烘干方法；

以上就是将解决这个问题的过程拆成一个个方法（是没有对象去调用的），通过一个个方法的执行来解决问题。

面向对象的解决方法：

1. 我先弄出两个对象：“洗衣机”对象和“人”对象

2. 针对对象“洗衣机”加入一些属性和方法：“洗衣服方法”“清洗方法”“烘干方法”

3. 针对对象“人”加入属性和方法：“加洗衣粉方法”“加水方法”

4. 然后执行

- 人.加洗衣粉()

- 人.加水()

- 洗衣机.洗衣服()

- 洗衣机.清洗()

- 洗衣机.烘干()

解决同一个问题 ，面向对象编程就是先抽象出对象，然后用对象执行方法的方式解决问题。

了解了什么是面向对象，那么我们为什么需要面向对象呢？

再考虑一个例子：
现在我们要设计一个小游戏，游戏里需要生成许多怪物，我们该如何实现呢？
面向过程的解决方法：

1. 设计一个生成怪物A的函数

2. 设计一个生成怪物B的函数

    ...

3. 编写怪物A的战斗逻辑

4. 编写怪物B的战斗逻辑

   ...

5. 编写怪物A的生存逻辑

6. 编写怪物B的生存逻辑

   ...

可见，在面向过程编程里，我们每生成一种怪物，可能都要重新设计一个函数，而对于同一种怪物的各个功能，在逻辑层面缺少联系，很难维护且不易阅读，而且这种编程方式不符合我们对真实世界的直觉认知。

面向对象的解决方法：

1. 设计一个怪物类，里面包含血量，攻击力，速度等基本信息，包含生成，战斗，死亡等基本方法。

2. 从怪物类中通过继承和多态，派生出怪物A类，怪物B类……

3. 生成怪物A类、怪物B类等的实例

可见，面向对象的编程方式较为符合我们对真实世界的直觉认知，且将数据与方法封装到一个对象里的做法也加强了数据与方法之前在逻辑层面的联系，若要对怪物类进行整体修改可直接在基类怪物类中进行修改，代码易于维护和编写。而且只要对外做到接口统一，使用者可不用了解类内部具体的细节，从而实现了代码的封装。

总结一下，面向对象的优点有：

1. 封装特性能够提高类的易用性，减少编程过程中代码出错的风险。

2. 继承最大的好处就是能够实现代码的复用。

3. 抽象更多的是能够让程序的设计和实现分离。

4. 多态最大的好处就是提高了程序的可扩展性。
