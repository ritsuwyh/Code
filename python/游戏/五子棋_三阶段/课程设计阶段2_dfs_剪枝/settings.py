
dic={'1':'黑方','0':'Empty','2':'白方'}#! 用特征值！！！！！！！！！
#! 用字符0 1 2 为了简化int转为str
black=[0,0,0]
white=[255,255,255]
#! 评估函数!!!!
#! 黑棋的评估值要大一点 因为黑色先手  对称的也要写
#.活4（有两个位置可以形成连5） 冲4（有一个位置可以形成连5）活3（走一步可以形成活4）.眠3（走一步可以形成冲4）活2（走一步可以形成活3）：形状自行脑补
#眠2（走一步可以形成眠3）
#活1（走一步可以形成活2）

# #! 这个参数特别重要！！！
# 规则一：己方棋型权重为正，对方棋型权重为负，且相同棋型时，对方权重的绝对值要大于己方(可以设置为2倍或者3倍关系)。这是因为要考虑到进攻和防守，现在是己方(ai白子)下，例如：如果己方走了一步棋形成了活2，而对方已经有一个活2，那么显然是对方占优一些，因为下一步是对方走，对方是可以形成更高等级的活3的，所以己方活2就没有对方活2等级高。

# 规则2：等级：连5>活4>冲4=活3>眠3=活2>眠2=活1，相邻等级的权重设置为相差20倍（也可以30，40倍）。这是因为会重复计算等级比较低的棋型，为了不影响总体判断，比如一开始放一个子，活1的权重会计算16次，我设置为20倍，那么活2的权重刚好比16倍活1还要大一些。

# 规则3：对方连5、对方活4、对方冲4、对方活3的绝对值要设置大一点，这一点非常重要！！如果此时对方已经连五，说明己方已经输了。如果此时对方有活4和冲4，那么如果己方没有连5的话，己方必须要去阻止对方的活4和冲4。像这样可以分析出其他棋型权重。
sum_dict_black={'11111':100000000,\
    '011110':1000000\
    ,'0110110':80000,'0101110':80000,'0111010':80000,\
    '11110':80000,'01111':80000,'11101':80000,'10111':80000,'11011':80000,\
    '011100':100000,'001110':100000,'011010':100000,'010110':100000,\
    
    '11100':50,'00111':50,'11010':50,'01011':50,'10011':50,'11001':50,'10101':50,\
    '001100':50,'010100':50,'001010':50,'011000':50,'000110':50,'010010':50,\
    '11000':3,'00011':3,'10100':3,'00101':3,'01100':3,'00110':3,'10010':3,'01001':3,'10001':3,\
'00100':3,}#! 黑色方权重更大  可用于贪心白方AI防守 也可以用于dfs模拟玩家出棋
#! 为了防止重复计算对称的 分成lst1 和lst2 
#! 白棋能走4就走4
sum_dict_white={'22222':100000000,\
    '022220':1000000\
    #! 下面这一行其实就是强势的活3
    ,'0220220':80000,'0202220':80000,'0222020':80000,\
    '22220':80000,'02222':80000,'22202':80000,'20222':80000,'22022':80000,\
    '022200':100000,'002220':100000,'022020':100000,'020220':100000,\
    '22200':50,'00222':50,'22020':50,'02022':50,'20022':50,'22002':50,'20202':50,\
    '002200':50,'020200':50,'002020':50,'022000':50,'000220':50,'020020':50,\
    '22000':3,'00022':3,'20200':3,'00202':3,'02200':3,'00220':3,'20020':3,'02002':3,'20002':3,\
    '00200':3}#! 白方权重更大 进攻

special_dict={ '011100':8000,'022200':400,'011010':8000,'022020':400,}
para_special_dict={'001110':8000,'002220':400,'010110':8000,'020220':400}

special_lst=['011100','022200','011010','022020']
para_special_lst=['001110','002220','010110','020220']

lst1=sorted(sum_dict_black.keys(),key=lambda x:sum_dict_black[x],reverse=True)
lst2=sorted(sum_dict_white.keys(),key=lambda y:sum_dict_white[y],reverse=True)

# lst1=['11111','22222','011110','022220','0110110','0220220','0101110','0202220','11110','22220','11101','22202','11011','22022'\
#     ,'011100','022200','011010','022020','11100','22200','11010','22020','10011','20022','10101','20202','001100','002200','010100'\
#         ,'020200','011000','022000','010010','020020','11000','22000','10100','20200','01100','02200','10010','20020','10001','20002','00100','00200']#,'0101010','0202020'
# lst2=['11111','22222','011110','022220','0110110','0220220','0111010','0222020','01111','02222','10111','20222','11011','22022'\
#     ,'001110','002220','010110','020220','00111','00222','01011','02022','11001','22002','10101','20202','001100','002200','001010'\
#         ,'002020','000110','000220','010010','020020','00011','00022','00101','00202','00110','00220','01001','02002','10001','20002','00100','00200']#,'0101010','0202020'
