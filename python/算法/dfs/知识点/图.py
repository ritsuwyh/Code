
#! 握手定理 边数等于总度除2  总度为邻接矩阵所有元素的和
# 握手定理：
# 在任何有向图图中，所有顶点的度数之和等于边数的2倍，所有顶点的入度之和等于所有顶点出度之和，等于边数 等于邻接矩阵所有元素的和
# 无向简单图，同样所有顶点的度数之和等于边数的2倍
#! 无向图度数统计 有向图度数统计
#! 图的储存方式 邻接矩阵 0,1 有n个顶点就是n阶方阵
#todo 一定要判断是有向还是无向
#!无向图填u-v边  G[u][v]=1 G[v][u]=1  无向图是对称矩阵 G[i][i]=1 说明有自环
#!有向图填u-v边 G[u][v]=1 有向图第i行上所有元素的和是顶点i的出度
#!有向图第j列上所有元素的和是顶点j的入度
#!带权值的图 分为带权无向图 带权有向图 读入u-v边 需要多读入一个参数k(权值) G[u][v]=k!=0 说明u和v之间有边 其值k为边(u,v)的权值
#!输出以每个点为起点的边权之和，那其实就是这个邻接矩阵每一行的和


#! 判断完全图 根据邻接矩阵判断边的个数
#! 图中边的权值与入度和出度一点关系都没有
#! 0 4 2
#! 2 0 1 
#! 2 0 0
#! 第一个顶点的出度是2 (看第一行非0元素的个数)

#! 邻接表的实现 c++vector组  python list中list
#! 邻接表与邻接矩阵的区别 及各自的优缺点
#!邻接表: 稀疏图 点多边少的时候 可记录多条边
#!邻接矩阵: 稠密图 点少边多 判断两点之间是否有边
#!用邻接表存图有两个优点。 节省空间：当图的顶点数很多、但是边的数量很少时，如果用邻接矩阵，我们就需要开一个很大的二维数组，最后我们需要存储 n^2 个数。
# 但是用邻接表，最后我们存储的数据量只是边数的两倍。 可以记录重复边：如果两个点之间有多条边，用邻接矩阵只能记录一条，但是用邻接表就能记录多条。
# 虽然重复的边看起来是多余的，但在很多时候对解题来说是必要的。 当然，有优点就有缺点，用邻接表存图的最大缺点就是随机访问效率低。比如，我们需要询问点 aa 是否和点 bb 相连，
# 我们就要遍历G[a]，检查这个vector里是否有 bb。而在邻接矩阵中，只需要根据G[a][b]就能判断。 因此，我们需要对不同的应用情景选择不同的存图方法。如果是稀疏图（顶点很多、边很少），一般用邻接表；
# 如果是稠密图（顶点很少、边很多），一般用邻接矩阵。 当点数较多（多于 5000）时，使用邻接矩阵会超出空间限制，需要使用邻接表。
#! 邻接表的实现
#! 邻接表的输出 for i in range(len(lst)): for j in range(lst[i]) print(i,j)
# #todo 带权图的邻接表存储方式 c++ 结构体 python 用类
# struct node{
#     int v;#用来记录连接的点
#     int w;#用来记录这条边的边权
# };
# 我们通常把有向图中加入一条边写成一个函数，
# #!例如加入一条 有向有权边 
# (u, v)(u,v)、边权为 w,就可以用如下的函数来实现（我们需要把图定义成全局变量）
# vector<node> G[105];
# void insert(int u,int v,int w){
#     node temp;
#     temp.v=v;
#     temp.w=w;
#     G[u].push_back(temp);
# }
# #!插入一条无向有权边
# void insert2(int u,int v,int w){
#     insert(u,v,w);
#     insert(v,u,w);
# } 
#! 带权邻接表的输出


#! 树 无向连通图不存在回路  有根树 无根树
# 树上节点深度: 一个节点到根的距离
# 包含 n 个结点的有根树的一些性质： 
# 每棵非空有根树有且仅有一个根结点。
# 父结点可以有多个孩子结点，除根结点外，其余的结点有且仅有一个父结点。
# 根结点没有父结点，叶结点没有孩子结点。  
# 若树上的结点数为 n，则边数一定为 n-1。  #! 所以n个节点 只需要循环n-1次
# 树上的任意一对结点之间 有且仅有 一条路径。
# 节点的深度 是指该点在第几层 根在第一层
# 边权 树是一种特殊的图，一棵树同时也是一个图。我们之前学习图的时候都知道有一种图叫做带权图。那么树作为图的一种，每条边自然也能被赋予权值。  
# 叶子结点 树的叶子结点指的是没有任何孩子的结点，它可以有父亲，但是一定没有孩子。那么我们怎
# 么判断叶子结点呢？很简单。既然它只有父亲没有孩子，那么和它相邻的点就一定只有父亲结点，因此，在树的点数大于 1 的情况下 叶子结点在 图 上的度数必然为1。
# 利用这个性质可以很好的在树当中寻找出叶子结点。
# 需要注意区分 树 上 的度和 图 上 的度数的区别:树上的度指的是一个结点所拥有的子树数目，
# 而图上的度数指的是一个结点所连接的边的条数。叶子结点在图上的度数必为1,而叶子结点不会有任何子树，所以在树上的度是 0 。
#距离 树上的每两个点之间有且只有一条简单路径，因此，我们定义树上的两个结点的距离为这两个点路径上的所有边的边权之和(在不带权图中就是经过的边的数量)。  
#直径树中所有最短路径距离的最大值即为树的直径。可以发现，树的直径一定是从一个叶子结点到另一个叶子结点。
#! 例题 最短直径 贪心


#!完全二叉树 满二叉树
#一颗完全二叉树可以用一维数组来存储 规定根节点的编号是1 那么如果一个父节点的编号为k 其左儿子的编号就是2k 右儿子是2k+1 弱儿子编号是x 那么其父节点编号为x//2(python里面)
#如果一个完全二叉树有N个节点 那么完全二叉树的高度为以2为底的对数N
#!堆 一种特殊的完全二叉树 所有父节点都比子节点要小 最大堆 最小堆
#down up 堆的生成*2 堆排序*2 第二种省略
#! 下面都是最小堆



n=eval(input("请输入二叉完全树的节点数:"))
tree=list(map(int,input().split()))
tree.insert(0,None)
#*应用 已有一个最小堆 现在删去最小的数即根节点 并向堆中放入一个新的数 重新构造最小堆 只需要将新的元素放到堆顶 然后siftdown
def siftdown(i):#! i是需要向下调整的编号
    flag=False#! 记录是否继续向下
    while i*2<=n and flag==False:#! 前一个条件说明有孩子
        if tree[i]>tree[i*2]:#! 如果他大于左孩子
            t=i*2#! t用于记录要换到的编号
        else:
            t=i   
        #todo 如果他有右孩子 再对右孩子进行讨论
        if i*2+1<=n:
            #todo 如果右孩子的值更小 更新较小的节点编号
            if tree[t]>tree[i*2+1]:
                t=i*2+1
        #todo 如果判断编号改变了 说明孩子中有比父节点更小的
        if t!=i:
            tree[i],tree[t]=tree[t],tree[i]#! 更换元素值
            i=t#! 更换编号 这句话很重要 以便下次继续调整
        else:#! 说明已经是比孩子都小了 不需要调整了 可以退出while了
            flag=True
#*应用 向堆中加入一个元素 重新构造最小堆 只需将新的元素放到堆的最后面 然后siftup
def siftup(i):#!i是需要向上调整的节点编号
    flag=False
    if i==1:
        return 
    while i!=1 and flag==False:
        if tree[i]<tree[i//2]:
            tree[i],tree[i//2]=tree[i//2],tree[i]
        else:
            flag=True
        i=i//2#! 这句话很重要 以便下次继续调整
        
#! 由完全二叉树建立堆的两种方法

#!方法1
def creat():
    for i in range(1,n+1):
        siftup(i)
    
#!方法2
#def creat():
#    for i in range(n//2,0,-1):
#       siftdown(i)

print(tree[1:])#!注意一直要把tree[0]排除在外！！！   

#todo 堆排序:见书

#!14
#!99 5 36 7 22 17 46 12 2 19 25 28 1 92




