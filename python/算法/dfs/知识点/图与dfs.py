
#!求出字典序最小的 DFS 序，首先肯定要从 1 号点开始，
#! 然后要求每一次走的都是当前能走的编号最小的点(贪心223)
#!实际写代码的时候我们只需要把邻接表的每一行都从小到大排序，
#!按照这样的顺序进行图的遍历，得到的 DFS 序就是最小的了。

#!  依据字典序人为规定方向
# 回顾之前学习的迷宫问题，如果约定往上走一步是'U'，
# 往下走一步是'D'，往左走一步是'L'，往右走一步是'R'，
# 一个从起点走到终点的方案就可以写成一个字符串，
# 现在希望求解字典序最小的方案，如何去做？ 
# 其实对于当前所在的点，下一步就按照
# 下（'D'），左（'L'），右（'R'），上（'U'）的顺序依次来尝试就可以了，
# 相当于每一步也是选了字典序尽可能小的方案。


#! 树总有它的特殊性，那就是从根开始搜索，到达每个点的时候一定只有它的父节点是之前访问过的，
#! 所以我们并不必使用vis数组记录每个点有没有被访问过，只需要记录每个点的父节点是哪个节点，
#! 这样看这个点连着的节点时，就只需要判断它不是这个点的父节点就可以往下搜索了。


#! 平常输入树的方式有很多，对于有向树来说 比如明确告诉了每个点的父节点，或者明确说明了一个点是另一个点的父节点，
#! 此时，我们只需要父节点向子节点连有向边就足够了，对于根节点，有可能会明确知道，如果不知道，
#! 那可以统计每个点是不是有父节点或者统计每个点的度数来找到根节点，此时fa这个参数也可以就不用了。 

#! 如果没有明确说明父子关系，需要建无向边，如果已知一个点为根，那就以那个点为根
#!如果不知道根是哪个点但以哪个点为根都不影响结果，就可以任意指定，一般习惯用 1 。
#! fa 参数随便传一个就行

#! 树上搜索c++代码如下:
# void dfs(int u,int fa){
#     cout<<u<<endl;
#     for(int i=0;i<G[u].size();i++){
#         int v=G[u][i];
#         if (v!=fa){
#             dfs(v,u);# v的父节点就是我们现在的节点u
#         }
#     }
# }

#! 子树 包括当前节点和他底下所有节点的一棵树
#!一个子树可以拆成子树根（一个节点）和每一棵以它的孩子为根的子树，所以这棵子树的大小就是所有以它的孩子为根的子树的大小的和再加 1 。