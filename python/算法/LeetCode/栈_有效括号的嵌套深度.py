
#! 要读懂题干
#! 可以利用栈来求括号的嵌套深度
#! 选择A B 的依据 选择层的个数相差最小的 经过分析不能打某一层拆开 一部分分给A另一部分分给B 
#!要实现这样的对半分配，我们只需要把奇数层的 ( 分配给 A，偶数层的 ( 分配给 B 即可

#! 原理
# 如果当前字符是 (，就把 ( 压入栈中，此时这个 ( 的嵌套深度为栈的高度；

# 如果当前字符是 )，此时这个 ) 的嵌套深度为栈的高度，随后再从栈中弹出一个 (。
# 括号序列   ( ( ) ( ( ) ) ( ) )
# 下标编号   0 1 2 3 4 5 6 7 8 9
# 嵌套深度   1 2 2 2 3 3 2 2 2 1 


# 这题是这样的，要让A和B的最大深度最小，关键就是，AB你俩的深度谁都别涨太快。别A的深度都到10了，B还0深度呢。所以很简单，涨深度的时候，谁比较浅，我就给谁涨。降的时候，谁比较深，我就给谁降。

# 啥叫“涨深度”呢？那就是'('啊，来一个左括号，那深度就涨一格，所以AB谁浅就给谁涨。深度一样的话呢，就随便给涨一个。

# 涨完了你得降啊，啥叫“降深度”呢？那就是右括号啊，右括号来了谁深先降谁。所以代码就是：
class Solution:
    #! 题目已经说了给一个合法的括号表达式
    def maxDepthAfterSplit(self, seq: str) -> list[int]:
        ans=[]
        a=b=0 #这是深度，初始都是0
        for s in seq:
            if s=='(':
                if a<=b:
                    a+=1
                    ans.append(0)
                else:
                    b+=1
                    ans.append(1)
            elif s==')':
                if a>b:
                    a-=1
                    ans.append(0)
                else:
                    b-=1
                    ans.append(1)
        return ans