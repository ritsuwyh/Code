Python的特点
• 脚本语言（script language） 
–  解释 执行(官方解释器: CPython) – 可以避免编译过程，方便处理各种简单任务
• 胶水语言（glue language）
– 可以在Python中调用C/C++等语言代码
– 支持多语言混合编程
• 动态类型语言、强类型语言
• 支持函数式、命令式、结构化、面向对象等范式
• 跨平台、资源丰富

Python 解释执行 
- 由解释器逐行执行 
– 文件方式/交互方式相同
– 依赖于运行环境
– 易于修改更新

C++ 编译执行
– 编译-目标代码
– 链接-可执行文件
– 运行
– 运行时可以脱离编译器
– 编译运行流程复杂

变量命名规则
• 只能包含字母、数字和下划线
– 不能以数字开头、不能包含空格
• 不能使用Python的关键字
• 不建议使用内建函数名


Python是强类型语言，每个值的类型都是确定的，不进行隐式
的类型转换
• Python是动态类型语言，值和变量的类型是运行时确定的（相
对于编译时通过定义、申明确定

当多个操作符同时出现时，考虑操作符的优先级和结合性
– 算术运算符 > 位运算符 > 关系运算符 > 逻辑运算符
– 运用括号提升程序可读性


常用的函数
https://blog.csdn.net/weixin_45042620/article/details/106479222

传入参数
https://blog.csdn.net/cadi2011/article/details/84871401
https://blog.csdn.net/sinat_38682860/article/details/88618603

https://www.cnblogs.com/wilber2013/p/4645353.html 深浅拷贝！
Shallow copy v.s. Deep copy
copy()函数为浅拷贝 b=a.copy() a和b是两个独立的对象 但是其子对象还是指向同一对象
copy.deepcopy()为深拷贝 a与b是 完全独立 两个对象 


Mutable v.s. Immutable数据类型
• Mutable类型: 可变对象 对mutable对象进行操作会直接在其上面进行更改 
– list, dict, set, 大部分的自定义类型
• Immutable类型：会返回一个新的对象 而无法对原来的对象造成影响
– int, bool, float, tuple, str, frozenset


反复修改一个immutable，需要不断创建新的对象,那还不如构建一个mutable的list，再利用内建方法join进行组合（交给解释器去优化）


元组（mutable） v.s. 列表（immutable）
– 前者更高的效率、更少的空间 
更重要的是immutable可以作为参数传递而不用担心被修改，
在多线程、多对象共享环境下都有更好的安全性
– *元组可以作为字典的键值或集合元素，列表不行

• 仅有三种mutable的容器可以用解析方法创建（list, set, dict）


可迭代对象和迭代器对象
• 可迭代对象
– 通过iter() 函数返回一个迭代器
• 迭代器对象
– 指向可迭代对象中某个位置
– 通过next()函数访问其下一个位置的元素
– 直到无更多元素结束
>>> x = iter(mylist)
>>> tuple(x)
(1, 2, 3)
>>> tuple(x)
()


搜索:
求解过程（搜索）：
对一定范围内数字进行遍历+条件判断
求解过程（搜索）：
对一定范围内的状态进行遍历+条件判断

状态搜索的过程:
• 从初始状态出发
• 当前状态下，执行某合法动作，状态发生改变（transmission）
    – 影响动作和合法性的状态
    • 如：当前的对弈格局、当前所处的城市等
    – 影响终局形势的状态（代价cost/奖赏reward）
    • 如：剩余手牌数、移动步数等
• 重复上条步骤，直到达到终止状态结束
    – 搜索结果：所有经过的状态/动作构成的序列
• 如果存在多条到达终止状态的路径，根据条件进行选择
    – 如：最短移动路径、最少移动步数、最多剩余棋子数等


搜索基本⽅法
• Uniformed Search（Blind Search）
– 如果能够高效遍历所有可能，则可得到确定的解（穷举）
– 重点：不重复、不遗漏
• 设计遍历的方法、顺序（深度优先、广度优先）……

• Informed Search
– 每次选择当前看来最好的解（贪心搜索，Greedy Search）
• 如：吃子最多的落子（黑白棋）、距离最短的城市（最短距离）、
出牌最多的走法（斗地主）……
• 不一定能够保证得到正确的解
– *保证最优选择的方法：A* Search

• 是否完全（Complete）、是否最优（Optimal）、时空复杂度
• 综合利用知识可能会得到更快的搜索速度，比如优先级


1. 如何用函数进行功能抽象？
函数是程序的一种抽象，它通过封装实现代码复用。可以利用函数对程序进行模块化设计。 
程序由一系列代码组成，如果代码是顺序但无组织的，不仅不利于阅读和理解，也很难进行维护和升级。因此，把代码当成资源的抽象，形成易于理解的结构

2. 请基于frame计算模型描述python函数调用的过程，并描述python中如何找到对标识符绑定的对象
函数执⾏环境
• 函数调用发生时，为被调用函数创建frame (local，局部作用域)
– 记录形参和实参的绑定关系
– 记录函数执行过程中发生的新的绑定
• 函数执行的环境包含global frame和该函数的local frame
– 依次在local frame、global frame中寻找绑定

函数中的局部变量
• 函数中的形参和变量的作用域（scope）仅限于当前函数
– 因为，其仅存在于当前函数的local frame中
– 因此，不同函数中的局部变量互相不会产生影响
• 函数中的形参和变量的作用域（scope）仅限于当前调用
– 因为，每次调用创建一个独立的local frame
– 因此，同一个函数的多次不同调用互相不产生影响

3. 请基于frame计算模型解释global和nonlocal关键字的作用。
global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用，而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误
global:当前frame中不再创建x的绑定关系，而是使用global frame中的绑定关系
nonlocal:当前frame中不再创建x的绑定关系，而是使用parent frame（global除外）中的绑定关系

4.什么是函数的副作用？python中函数有哪些途径可以产生副作用？
函数副作用是指函数在正常工作任务之外对 外部环境 所施加的影响。 具体地说，函数副作用是指函数被调用，完成了函数既定的计算任务，但同时因为访问了外部数据，尤其是因为对外部数据进行了写操作，从而一定程度地改变了系统环境。 函数的副作用也有可能是发生在函数运行期间，由于对外部数据的改变，导致了同步运行的外部函数受到影响。
比如python 中 对可变元素的更改
Immutable参数是避免函数副作用的一种机制

注:
一个函数中同一个变量的绑定一定在同一个frame中
def localf():
    print(x)
    x = 5
x = 10
localf()
上述代码会报错

def func():
    global x
    print(x)
    x+=1
x=100
func()
print('--------')
print(x)
上述代码可以正常运行 注意global要放到最前面


 函数执行过程：
– 将参数argument与函数的形参formal
parameter进行绑定
– 执行函数定义子句中的操作语句
– 执行return语句时结束子句执行，并将return表达式的计算结果返回

包含嵌套函数的计算模型
• 调用嵌套定义的函数时，同样需要创建新的local frame。
• 此时，frame之间发生了嵌套关系
绑定关系按照current local frame -> parent frame -> global frame的顺序进行查找




1. 什么是抽象、什么是封装？python中进行面向对象程序设计，如何体现抽象和封装？
抽象与封装是两个重要的程序设计手段，主要是用来驾驭程序
的复杂度，便于大型程序的设计、理解与维护。
• 对于一个程序实体而言，
– 抽象是指该程序实体的外部可观察到的行为，不考虑该程序
实体的内部是如何实现的。
– 封装是指把该程序实体的具体实现细节对使用者隐藏起来的
一种机制

面向对象程序设计具有以下几个特征：
– 程序由若干对象组成，每个对象是由 数据 以及对这些数据所 能实施的操作 所构成的封装体；
– 对象的特征由相应的类来描述；
– 对数据的使用是通过向包含数据的对象发送消息来实现的；
– 一个类所描述的对象特征可以从其它的类继承获得。

1.b python中进行过程的抽象和封装可以体现在哪些方面？

模块 函数 类 


2. 面向对象程序设计与基于过程的程序设计方式有什么差别？面向对象程序设计有哪些基本特征？
面向过程:自顶向下，逐步细化 
而面对对象的模块化更深，数据更封闭，也更安全 面向对象的封装性更强面对对象的思维方式更加贴近于现实生活，更容易维护的扩展功能
有四个基本特征:抽象 封装 继承 多态


3. python中如何完成对对象状态的初始化和消亡前处理？
初始化:
pyhton用__new__来创建对象(__new__相当于Java中的构建函数)，对象创建好之后会立即调用__init__方法，__init__方法有个参数self就是刚才__new__创建好的那个对象。
通过我们有__init__方法中给对象的属性进行赋值，或者动态线对象添加属性并赋值
消亡处理:
python和Java一样都是垃圾自动回收，不需要我们显示地销毁对象。执行del obj时会调用对象的__del__方法，这样对象的引用计数会减1，当对象的引用计数为0时，对象就会被销毁，内存就会被回收。


4. 类成员和对象成员有什么区别？
一个类可以定义多个对象
每个对象实例都拥有类中定义的属性
每个对象可以拥有独立的属性（状态

继承的优点:(开闭原则)
利用继承的多态进行程序设计时：
– 可以通过继承引入新的类，保持或者更新原有的功能（open）
– 对对象进行使用的代码（高层代码）可以保持不变（closed）
注意在继承的时候,多个父类的申明顺序也会影响程序的运行结果

动态类型语言和静态类型语言的主要区别是什么？
    静态类型语言: 
        编译时的类型检查确定程序中可能的错误 
        编译代价较大但是运行效率更高
    动态类型语言:
        运行时的检查报告可能的类型错误
        运行时自由度更高 开发更为便捷灵活 开发束缚相对小


1.异常处理机制用于处理什么样的问题？结构化异常处理机制有什么特点？
通常处理的问题:
程序运行时异常并不总是发生 但是往往无法避免 有些异常是不可避免的，但我们可以对异常进行捕获处理，防止程序终止。借助异常处理机制，还可以在程序崩溃前做一些必要的工作，例如将内存中的数据写入文件、关闭打开的文件、释放分配的内存等。
特点:
就是在程序运行出现错误时，让 Python 解释器执行事先准备好的除错程序，进而尝试恢复程序的执行。 Python 异常处理机制会涉及 try、except、else、finally 这 4 个关键字，同时还提供了可主动使程序引发异常的 raise 语句

2.解释器如何处理Python程序中的语法错误？请从EAFP的角度对此进行解释。
当代码不符合 Python 关键字、命名风格或编程结构时，会发生语法错误异常。解释器在其解析阶段看到无效语法并引发SyntaxError异常。程序在发生语法错误的地方停止并失败。语法错误是无法处理的异常。
EAFP:Easier to Ask for Forgiveness than Permission.
通俗的理解一下:即解释器相信程序会正确执行，然后如果出错了我们再处理错误

3.python的模块是什么？一个模块能包含哪些内容？
Python 模块，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。 把相关的代码分配到一个模块里能让你的代码更易于维护，更易懂。 
模块能定义函数，类和变量，模块里也能包含可执行的代码。

4.请谈一谈利用模块写python程序有什么可能的好处？
模块让能够有逻辑地组织你的 Python 代码段，可以被其他地方引用。
使代码更加清晰简洁，易于维护，功能的添加，功能的修改。

使用模块还可以避免函数名和变量名冲突。

1.请简单叙述numpy, scipy, matplotlib, ipython, sympy, pandas工具的功能，并对每个工具分别列举一个具体的应用场景。
Numpy是python的一种开源的数值计算扩展;Numpy可用来存储和处理大型矩阵;Numpy支持大量的维度数组与矩阵运算。

SciPy： 主要功能是建立在NumPy上,从而它的数组大量的使用了NumPy的。 它的不同子模块相应于不同的应用。像插值,积分,优化,图像处理,特殊函数等等

matplotlib：绘图库。使用它可以很方便的绘制出版质量级别的图形。

IPython：ipython是一个python的交互式shell,比默认的python shell好用得多,支持变量自动补全,自动缩进,支持bash shell命令,内置了%timeit等函数。

Sympy: 科学计算库，⽤⼀套强⼤的符号计算体系完成诸如多项式求值,求极限,解方程,求积分微分方程等计算问题。

Pandas: 数据分析包，提供了高效的操作大型数据集所需的工具


2. array 比 原生list 的优势

1)

numpy极大地简化了向量和矩阵的操作处理它将常用的数学函数都支持向量化运算，使得这些数学函数能够直接对数组进行操作，将本来需要在Python级别进行的循环，放到C语言的运算中，明显地提高了程序的运算速度。

2)

Python列表本质上是一个指针数组，每个指针指向一个包含与元素相关信息的位置。这在内存和计算方面增加了很多开销。当列表中存储的所有对象都是同一类型时，大多数信息都是冗余的。而使用NumPy数组，即具有相同数据类型的元素。这使得它在存储和操作数组方面更加高效。另外，使用NumPy数组，还可以执行元素操作，这是使用Python列表不可能做到的。



3. 结果不同  使用.T 转置操作改变了内部数据的存储方式 而使用reshape函数仅仅是改变了视图并没有改变内部的存储顺序









• 降低维度的⽤途
– 可视化、降低噪⾳影响、提升泛化能⼒、降低资源
消耗等
降维的方法 PCA KPCA


PCA算法
• 设有m条D维数据构成X，⺫标为压缩到d维：
– 将每个样本中⼼化（零均值化）
– 计算协⽅差矩阵XX.T
– 对协⽅差矩阵做特征值分解 
– 最⼤的d个特征值所对应的特征向量构成投影矩阵W

求特征值的过程 svd奇异值分解

非线性降维方法： 
MDS – 保持样本之间的距离不变
ISOMap - 保持样本之间的距离不变
LLE - 保持局部距离
t-SNE


如何评估学习结果(评估方法)
– 将Examples划分为训练集和测试集（训练集和测试集不应该有重叠样本）
训练集性能评估 测试集性能评估 可以使用 错误率 精度
– 留出法（hold-out） •将测试样本从训练集中移除
– 交叉验证法（cross validation） •划分数据后进⾏多次留出


回归 分类
#! 简答题:
#todo 1、回归任务和分类任务的联系与区别。
# 简单来讲，分类任务 和 回归任务 的区别在于 需要预测的值的类型：
# 回归任务，是对 连续值 进行预测（比如 多少）；
# 分类任务，是对 离散值 进行预测（比如 是不是，属不属于，或者 属于哪一类）。
#* 即输入变量与输出变量均为连续变量的预测问题是回归问题,输出变量为有限个离散变量的预测问题成为分类问题。

#todo 2、线性回归和逻辑斯蒂回归的关系。
# 1）线性回归要求变量服从正态分布，logistic回归对变量分布没有要求。
# 2）线性回归要求因变量是连续性数值变量，而logistic回归要求因变量是分类型变量。
# 3）线性回归要求自变量和因变量呈线性关系，而logistic回归不要求自变量和因变量呈线性关系
# 4）logistic回归是分析因变量取某个值的概率与自变量的关系，而线性回归是直接分析因变量与自变量的关系








KNN 算法
• k近邻（k-Nearest Neighbors，k-NN）
– 查询与待预测样本最相近的k个训练样本
– 使⽤k个样本的投票决策决定分类结果
– 使⽤k个样本的均值决定回归结果


k的选择
• k较⼩时
 – 决策更为接近数据本⾝的分布 – 较容易收到噪⾳和异常数据的影响
• k较⼤时
– 决策边界更为平滑 – 对数据变化的敏感程度下降
• k为整个训练集时？
- 无意义


学习问题的处理思路:
• 根据应⽤目标确定学习任务
– 分类、回归
• 对数据进⾏处理
– 数值转换、降维
• 观察数据，选择合适的模型
• 分析结果，对现有⽅案进⾏改进

有监督学习和无监督学习的区别
1.有标签就是有监督学习,没有标签就是无监督学习,说的详细一点,有监督学习的目的是在训练集中找规律,然后对测试 数据运用这种规律,而无监督学习没有训练集,只有一组数据,在该组数据集内寻找规律。
2. 无监督学习方法在寻找数据集中的规律性,这种规律性并不一定要达到划分数据集的目的,也就是说不一定要“分类”。比如,一组颜色各异的积木,它可以按形状为维度来分类,也可以按颜色为维度来分类。(这一点比监督学习方法的用途要广。...
3.有监督学习要实现的目标是“对于输入数据X能预测变量Y”(有答案和方法的学)。而无监督学习要回答的问题是“从数据X 中能发现什么”(自学)。




基于邻近度的技术（距离度量）：通常可以在对象之间定义邻近性度量，异常对象是那些远离大部分其他对象的对象。当数据能够以二维或者三维散布图呈现时，可以从视觉上检测出基于距离的离群点。
异常检测的目的:
• 发掘数据中包含的不⼀致性
– 消除噪⾳干扰，提⾼分析精度
– 检测异常⾏为（系统故障、欺诈等）


k-Means聚类算法
• ⼀种针对聚类中⼼进⾏优化的⽅法：
• 1. 初始化k个聚类中⼼�� 
• 2. 将每个x划⼊到距离最近的聚类中⼼�� 
• 3. 重新计算每个类的中⼼�� 
• 4. 转⾄2继续执⾏，直⾄聚类不发⽣变化或达到迭代次数


Apriori(关联规则)算法：
• 基于频繁项集候选的⽣成和检测的⽅法
• Apriori：如果⼀个项集是⾮频繁的，那么它的所有 超集都不应该被⽣成或者检测
• 流程：
– 扫描数据，⽣成宽度为1的频繁项集 
– 从k-频繁项集⽣成k+1-频繁项集的候选（Apriori） 
– 扫描数据，对候选进⾏测试，得到k+1-频繁项集 
– 重复直⾄不再⽣成新的频繁项集或者新的候选


逻辑和推理:
WDNMD